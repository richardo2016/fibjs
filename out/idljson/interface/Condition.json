{
  "declare": {
    "comments": "! @brief 条件变量对象\n\n 条件变量是利用纤程间共享的全局变量来进行同步的一种机制，主要包括两个动作：\n 1）一个线程等待某个条件成立，而将自己挂起；\n 2）另一个线程使条件成立，并通知等待的纤程向下执行。\n\n 为了防止竞争，每个条件变量都需要一个Lock的配合（Lock可自行显式创建并传递进来，也可交由fibjs为您创建）\n\n 通过使用条件变量，可以利用一个条件变量控制一批纤程的开关；\n\n 以下是两个纤程调度的实例：\n ```JavaScript\n var coroutine = require(\"coroutine\");\n var cond = new coroutine.Condition();\n var ready = false;\n var state = \"ready\";\n\n function funcwait() {\n    cond.acquire();\n    while (!ready)\n        cond.wait();\n    state = \"go\"\n    cond.release();\n }\n\n coroutine.start(funcwait);\n\n cond.acquire();\n console.log(state)\n ready = true;\n cond.notify();\n coroutine.sleep();\n console.log(state);\n ```\n will output:\n ```sh\n ready\n go\n ```\n ",
    "type": "interface",
    "name": "Condition",
    "extend": "Lock",
    "doc": {
      "descript": "条件变量对象",
      "detail": [
        "条件变量是利用纤程间共享的全局变量来进行同步的一种机制，主要包括两个动作：",
        "1）一个线程等待某个条件成立，而将自己挂起；",
        "2）另一个线程使条件成立，并通知等待的纤程向下执行。",
        "",
        "为了防止竞争，每个条件变量都需要一个Lock的配合（Lock可自行显式创建并传递进来，也可交由fibjs为您创建）",
        "",
        "通过使用条件变量，可以利用一个条件变量控制一批纤程的开关；",
        "",
        "以下是两个纤程调度的实例：",
        "```JavaScript",
        "var coroutine = require(\"coroutine\");",
        "var cond = new coroutine.Condition();",
        "var ready = false;",
        "var state = \"ready\";",
        "",
        "function funcwait() {",
        "   cond.acquire();",
        "   while (!ready)",
        "       cond.wait();",
        "   state = \"go\"",
        "   cond.release();",
        "}",
        "",
        "coroutine.start(funcwait);",
        "",
        "cond.acquire();",
        "console.log(state)",
        "ready = true;",
        "cond.notify();",
        "coroutine.sleep();",
        "console.log(state);",
        "```",
        "will output:",
        "```sh",
        "ready",
        "go",
        "```"
      ],
      "params": []
    }
  },
  "members": [
    {
      "memType": "method",
      "comments": "! @brief 条件变量构造函数（条件变量所需的锁由fibjs内部构造） ",
      "deprecated": null,
      "static": null,
      "async": null,
      "name": "Condition",
      "type": null,
      "params": null,
      "doc": {
        "descript": "条件变量构造函数（条件变量所需的锁由fibjs内部构造）",
        "detail": [],
        "params": []
      }
    },
    {
      "memType": "method",
      "comments": "! @brief 条件变量构造函数\n     @param lock 使用自行构造的锁\n     ",
      "deprecated": null,
      "static": null,
      "async": null,
      "name": "Condition",
      "type": null,
      "params": [
        {
          "type": "Lock",
          "name": "lock",
          "default": null
        }
      ],
      "doc": {
        "descript": "条件变量构造函数",
        "detail": [],
        "params": [
          {
            "name": "lock",
            "descript": "使用自行构造的锁",
            "detail": []
          }
        ]
      }
    },
    {
      "memType": "method",
      "comments": "! @brief 使纤程进入阻塞状态 ",
      "deprecated": null,
      "static": null,
      "async": null,
      "name": "wait",
      "type": null,
      "params": null,
      "doc": {
        "descript": "使纤程进入阻塞状态",
        "detail": [],
        "params": []
      }
    },
    {
      "memType": "method",
      "comments": "! @brief 通知一个被阻塞的纤程（最后加入纤程池的）向下继续执行 ",
      "deprecated": null,
      "static": null,
      "async": null,
      "name": "notify",
      "type": null,
      "params": null,
      "doc": {
        "descript": "通知一个被阻塞的纤程（最后加入纤程池的）向下继续执行",
        "detail": [],
        "params": []
      }
    },
    {
      "memType": "method",
      "comments": "! @brief 通知所有被阻塞的纤程向下继续执行 ",
      "deprecated": null,
      "static": null,
      "async": null,
      "name": "notifyAll",
      "type": null,
      "params": null,
      "doc": {
        "descript": "通知所有被阻塞的纤程向下继续执行",
        "detail": [],
        "params": []
      }
    }
  ]
}